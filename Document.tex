\documentclass{scrartcl}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{color}

\usepackage{iftex}
% Pakete u.a. für die Darstellung von Umlauten/Sonderzeichen
\ifPDFTeX
   \usepackage[utf8]{inputenc}
   \usepackage[T1]{fontenc}
   \usepackage{lmodern}
\else
   \ifXeTeX
     \usepackage{xltxtra}
   \else 
     \usepackage{luatextra}
   \fi
   \defaultfontfeatures{Ligatures=TeX}
\fi

\newcommand{\note}[1]{\textcolor{red}{\uppercase{#1}}}

\lstdefinelanguage{gf}
{
  morekeywords={abstract, flags, cat, fun, incomplete, concrete, of, open, in, lincat, lin, resource, param, oper, variants, table, interface, instance, def, data, lindef, printname,},
  sensitive=false,
  morecomment=[l]{--},
  morestring=[b]",
  stringstyle={\textit}
}
\lstdefinelanguage{cf}
{
  morekeywords={::=,.,},
  sensitive=false,
  morecomment=[l]{--},
  morestring=[b]",
  stringstyle={\textit}
}
\lstset{basicstyle=\ttfamily}

\newtheorem{exercise}{Exercise}

\title{Grammatical Framework for Python programmers}
\begin{document}
\maketitle
\note{disclaimer: i am not a python programmer but i'll try my best to explain concepts in a way that should be familiar to people who know python}

This short tutorial aims for Python programmers who would like to learn how to use the Grammatical Framework. It tries to meet you in familiar terrain and take you gently over to the way GF works.
\section{Types}

\subsection{Types in Python}

As a Python programmer you usually don't think too much about types. Unfortunately in GF types much more important.

Basic types in Python consist of Strings and Numbers (Integer, Float, Complex). A special case are boolean (logical expression) that will be explained later.
You can ask Python to give you the type for expressions. These types are automatically inferred, we don't even have to help Python to figure out what type
a variable has, as can be seen in the last example below.

\begin{verbatim}
>>> type(3)
<class 'int'>
>>> type(3.0)
<class 'float'>
>>> type("Foo")
<class 'str'>
>>> type(complex('1+2j')) # Is that still considered basic?
<class 'complex'>
>>> a=3
>>> type(a)
<class 'int'>
\end{verbatim}

These basic types can be used as the form compound types. Compound types are among others Lists, Tuples and Dictionaries.
These again can be part of other compound types as well, e.g. list containing lists as elements. Python does not really enforce
that all elements of a list have the same type (Disclaimer: In Python 3.5 they introduces strict typing and type annotations to solve that problem)\footnote{\url{https://docs.python.org/3/library/typing.html}} as you can see in the examples. To access elements in compound objects we
can use the \texttt{[]} operator.

\begin{verbatim}
>>> type([])
<class 'list'>
>>> type([1,2,3])
<class 'list'>
>>> type([1,2,"foo","bar"])
<class 'list'>
>>> type(())
<class 'tuple'>
>>> type((1,2))
<class 'tuple'>
>>> type((1,2,"foo"))
<class 'tuple'>
>>> type({})
<class 'dict'>
>>> type({'foo':1,'bar':2})
<class 'dict'>
>>> type({'foo':1,'bar':'baz'})
<class 'dict'>
\end{verbatim}

A special case in Python are truth values. Python does not just have a boolean datatype but interprets certain values of other types as truth values.

The values considered \textbf{false} are: 
\begin{itemize}
\item \texttt{None} i.e. the empty object
\item \texttt{False} i.e. the logical constant
\item \texttt{zero} of any numeric type, e.g. \texttt{0, 0.0, 0j}.
\item any empty sequence, e.g.\texttt{'', (), []}, i.e. empty string, tuple, or list.
\item any empty mapping, for example, \texttt{\{\}}.
\item instances of user-defined classes, if the class defines a \_\_bool\_\_() or \_\_len\_\_() method, when that method returns the integer zero or bool value False.
\end{itemize}

Everything else is considered \textbf{true}.

Another interesting group of datatypes are enumeration types where you define a type by listing all possible values. In Python enumerable types are objects of class \texttt{enum}. They can also be used as keys in dictionary. That gives us a way to express a mapping from grammatical number and case to a word form for german nouns.

\begin{verbatim}
>> class Number(Enum):
...   Sg = 1
...   Pl = 2
... 
>>> man={Number.Sg:"man",Number.Pl:"men"}
>>> man[Number.Sg]
'man'
>>> class Case(Enum):
...   Nom = 1
...   Gen = 2
...   Dat = 3
...   Acc = 4
... 
>>> mann={Number.Sg:{Case.Nom:"Mann", 
...                  Case.Gen:"Mannes", 
...                  Case.Dat:"Mann", 
...                  Case.Acc:"Mann"},
...       Number.Pl:{Case.Nom:"Männer", 
...                  Case.Gen:"Männer", 
...                  Case.Dat:"Männern", 
...                  Case.Acc:"Männern"}
... }
>>> mann[Number.Sg][Case.Gen]
'Mannes'
\end{verbatim}

\begin{exercise}
  If you haven't done so before, try the type() function in Python on different values and compare the output. 
\end{exercise}

One problem with this aproach is that Python does not enforce that we define mappings for all possible values which can be prone to errors. In the next example we only define values for some of the keys and then try to access undefined values which leads to an error.

\begin{verbatim}
>>> mann={
...   Number.Sg:{
...     Case.Nom:"Mann"
...   },
...   Number.Pl:{
...     Case.Dat:"Männern"
...   }
... }
>>> mann[Number.Sg][Case.Gen]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: <Case.Gen: 2>
\end{verbatim}

In addition we will have a look at functions. Functions in Python are usually defined and given a name with the \texttt{def} keyword. But Python also supports so-called anonymous functions or lambda expressions. Below the successor function is defined in two differnt ways

\begin{verbatim}
>>> def succ(x) :
...   return x+1
... 
>>> type(succ)
<class 'function'>
>>> succ2 = lambda x : x+1
>>> type(succ2)
<class 'function'>
>>> type(lambda x: x+1)
<class 'function'>
\end{verbatim}

\subsection{Static typing in GF}

Types in GF might seem a bit more complicated. Because we have abstract modules, concrete modules and resource modules we have different types that are important in different situations.

In the abstract syntax we do not really have to care about types. Here we can think linguistically and treat it more or less like context-free grammars, i.e. categories and syntax rules.

So we will start by looking at resource modules. Here we can use all the different types available in GF. These incluse Token lists (Str), Integers, Floats, and Bool. Most of them are defined in a module called Predef but Bool is defined in the module Prelude. Anonymous function types (lambdas) are standard types in GF and in resource modules the only way to define functions.

\lstinputlisting[language=gf]{src/SimpleTypes.gf}

As you can see in the examples above, for each variable we first give the type. That is best practice but for most of these simple cases it is not really necessary because GF can infer the type automatically. The only case where the type has to be given is the function.

Also there is a difference between the operators \texttt{+} and \texttt{++}. The reason for that is that GF has a distinction between strings and string tuples as well as between compiletime strings and runtime strings. For the moment we can say that string tuples are strings that are concatenated with a whitespace and strings are concatenated directly, i.e. \texttt{++} puts a space between two words and \texttt{+} does not. But \texttt{+} can only be used on compile-time e.g. in resource modules or with the exception of \texttt{oper}s and \texttt{++} can also be used at runtime e.g. when parsing input. If you don't understand that at the moment, that is perfectly fine. We will come back to this later.

Finally the function is esentially a lambda expression like the one used in Python. The difference is that the keyword \texttt{lambda} is replace by a backslash (\texttt{\textbackslash}) and the colon that separates the parameter from the function body is replaced by an arrow (\texttt{->}).

\begin{verbatim}
> cc s
"foobar"
0 msec
> cc st
"foo" ++ "bar"
0 msec
> cc b
Prelude.False
0 msec
> cc i
42
0 msec
> cc f
23.5
0 msec
> cc bar "foo"
"foobar"
0 msec
\end{verbatim}

In GF we also have ways to compose types to create new types. These compound types are called tables, records and function types.

Both tables and records can be seen as special forms of dictionaries. Tables are mappings from grammatical features to other values. A simple example are inflection tables that map e.g. from gender and number to the correct word form. Records usually are used to keep subparts of phrases as well as inherent grammatical features like the gender in nouns.

The main difference is that values in tables all have to have the same type while records can contain values of different types.

In the last kind of modules (we want to look at here) are concrete modules. Here we can use most of the things we have seen for the resource modules. But in the end it boils down to using strings in different ways. We store strings in record fields, select the right strings from tables and put them together at the right point. Sometimew we need to additionally store grammatical features. So we need strings, tables, records, and \texttt{param} types.

\section{Context-free Grammars}

A simple form of grammars are the so-called context-free grammars. They can be used in lots of applications both in computer science and linguistics but have limitations that encourage us to use more expressive formalisms like GF. We start with simple grammars in Python with NLTK, then show to translate them to a format that also works in GF and finally show how to implement them in the full GF formalism.

\subsection{Context-free Grammars in Python/NLTK}
\lstinputlisting[language=python]{src/NLTK-CF.py}
\lstinputlisting[language=python]{src/NLTK-CF2.py}
\lstinputlisting[language=python]{src/NLTK-CF3.py}
\begin{exercise}
  Write a context-free grammar accounting for the following sentences in Italian:

  Il mio hovercraft è pieno di anguille
  
  Io non acquisterò questo disco, perché è graffiato
  
\note{todo}

  Try to parse the following strings:

  
  
  The first one should be accepted and the second one rejected.

\end{exercise}
\subsection{Context-free Grammars in GF}
\lstinputlisting[language=cf]{src/GF-CF.cf}
\lstinputlisting[language=cf]{src/GF-CF2.cf}
\lstinputlisting[language=cf]{src/GF-CF3.cf}
\begin{exercise}
  Write the same grammar from the previous task in GF. Generate all trees accounted for by the grammar. Can you guess how many trees will be
  generated from a grammar?
\end{exercise}
\section{Step beyond Context-freeness: Tables and Records}
\section{Smart paradigms}
A smart paradigm in the GF jargon is a function that takes one or a few word forms and uses this information provided to generate the whole paradigm, i.e. the list of all word forms depending on the grammatical features the word is inflected on.

We can implement this kind of function both in Python and GF.
\subsection{Smart paradigms in Python}
\begin{exercise}
  Implement a function that takes a string of a noun and generates the regular noun paradigm for English as a dictionary of dictionaries. Also define all necessary grammatical features as enumeration types
\end{exercise}

\subsection{Smart paradigms in GF}

\note{pattern matching}

\lstinputlisting[language=gf]{src/SmartParadigm.gf}
\section{Other problems}
\begin{itemize}
\item compile-time vs. run-time strings
\item ...
\end{itemize}
\section{The GF-Python API}

\end{document}
